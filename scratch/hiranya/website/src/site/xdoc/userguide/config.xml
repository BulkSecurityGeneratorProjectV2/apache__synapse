<?xml version="1.0" encoding="ISO-8859-1" ?>
<!--
  ~  Licensed to the Apache Software Foundation (ASF) under one
  ~  or more contributor license agreements.  See the NOTICE file
  ~  distributed with this work for additional information
  ~  regarding copyright ownership.  The ASF licenses this file
  ~  to you under the Apache License, Version 2.0 (the
  ~  "License"); you may not use this file except in compliance
  ~  with the License.  You may obtain a copy of the License at
  ~
  ~   http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~  Unless required by applicable law or agreed to in writing,
  ~  software distributed under the License is distributed on an
  ~   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  ~  KIND, either express or implied.  See the License for the
  ~  specific language governing permissions and limitations
  ~  under the License.
  -->

<document>
    <properties>
        <title>Apache Synapse - Configuration Language Guide</title>
    </properties>
    <body>
        <section name="Contents">
            
        </section>
        <section name="Introduction">
            <p>
                Apache Synapse loads its configuration from a set of XML files. This enables the
                user to easily hand edit the configuration, maintain backups and even include the
                entire configuration in a version control system for easier management and control.
                For an example one may check-in all Synapse configuration files into a version
                control system such as Subversion and easily move the configuration files from
                development, through QA, staging and into production.
            </p>
            <p>
                All the configuration files related to Synapse are housed in the repository/conf/synapse-config
                directory of the Synapse installation. Synapse is also capable of loading certain
                configuration elements (eg: sequences, endpoints) from an external SOA registry.
                When using a registry to store fragments of the configuration, some configuration
                elements such as endpoints can be updated dynamically while Synapse is executing.
            </p>
            <p>
                This article describes the hierarchy of XML files from which Synapse reads its
                configuration. It describes the high level structure of the file set and the XML
                syntax used to configure various elements in Synapse.
            </p>
        </section>
        <section name="The Synapse Configuration">
            <p>
                A typical Synapse configuration is comprised of sequences, endpoints, proxy services
                and local entries. In certain advanced scenarios, Synapse configuration may also
                contain scheduled tasks, event sources, messages stores and priority executors.
                Synapse configuration may also include a registry adapter through which the mediation
                engine can import various resources to the mediation engine at runtime. Following
                diagram illustrates different functional components of Synapse and how they interact
                with each other.
            </p>
            <!-- Image goes here -->
            <p>
                All the functional components of the Synapse configuration are configured through
                XML files. The Synapse configuration language governs the XML syntax used to define
                and configure different types of components. This configuration language is now
                available as a <a href="http://synapse.apache.org/ns/2010/04/configuration/synapse_config.xsd">XML schema</a>.
            </p>
            <p>
                Typically the Synapse ESB is used to mediate the message flow between a client
                and a back-end service implementation. Therefore Synapse can accept a message on
                behalf of the actual service and perform a variety of mediation tasks on it such
                as authentication, validation, transformation, logging and routing. Synapse can also
                detect timeouts and other communication errors when connecting to back-end services.
                In addition to that users can configure Synapse to perform load balancing, access
                throttling and response caching. In case of a fault scenario, such as an authentication
                failure or a schema validation failure, the Synapse ESB can be configured to return
                a custom message or a SOAP fault to the requesting client without forwarding the
                message to the back-end service. All these scenarios and use cases can be put into
                action by selecting the right set of functional components of Synapse and combining
                them appropriately through the Synapse configuration.
            </p>
            <p>
                Depending on how functional components are used in the Synapse configuration, Synapse
                can execute in one or more of the following operational modes.
            </p>
            <subsection name="Service Mediation (Proxy Services)">
                <p>
                    In service mediation, the Synapse ESB exposes a service endpoint on the ESB, which
                    accepts messages from clients. Typically these services acts as proxies for existing
                    (external) services, and the role of Synapse would be to 'mediate' these messages
                    before they are delivered to the actual service. In this mode, Synapse could expose
                    a service already available in one transport, over a different transport; or expose
                    a service that uses one schema or WSDL as a service that uses a different schema or
                    WSDL. A Proxy service could define the transports over which the service is exposed,
                    and point to the mediation sequences that should be used to process request and
                    response messages. A proxy service maybe a SOAP or a REST/POX service over HTTP/S or
                    SOAP, POX, plain text or binary/legacy service for other transports such as JMS
                    and VFS file systems.
                </p>
            </subsection>
            <subsection name="Message Mediation">
                <p>
                    In message mediation, Synapse acts as a transparent proxy for clients. This way,
                    Synapse could be configured to filter all the messages on a network for logging,
                    access control etc, and could 'mediate' messages without the explicit knowledge
                    of the original client. If Synapse receives a message that is not accepted by any
                    proxy service, that message is handled through message mediation. Message mediation
                    always processes messages according to the mediation sequence defined with
                    the name 'main'.
                </p>
            </subsection>
            <subsection name="Task Scheduling">
                <p>
                    In task scheduling, Synapse can execute a predefined task (job) based on a user
                    specified schedule. This way a task can be configured to run exactly once or
                    multiple times with fixed intervals. The schedule can be defined by specifying
                    the number of times the task should be executed and the interval between
                    executions. Alternatively one may use the Unix Cron syntax to define task
                    schedules. This mode of operation can be used to periodically invoke a given
                    service, poll databases and execute other periodic maintenance activities.
                </p>
            </subsection>
            <subsection name="Eventing">
                <p>
                    In eventing mode, Synapse can be used as an event source and users or systems can
                    subscribe to receive events from Synapse. Synapse can also act as an event broker
                    which receives events from other systems and delivers them to the appropriate
                    subscribers with or without mediation. The set of subscribers will be selected
                    by applying a predefined filter criteria. This mode enables Synapse to integrate
                    applications and systems based on the Event Driven Architecture (EDA).
                </p>
            </subsection>
        </section>
        <section name="Functional Components Overview">
            <p>
                As described in the previous section, Synapse engine is comprised of a range of
                functional components. Synapse configuration language is used to define, configure
                and combine these components so various messaging scenarios and integration
                patterns can be realized. Before diving into the specifics of the configuration
                language, it is useful to have a thorough understanding of all the functional
                components available, their capabilities and features. A good knowledge on Synapse
                functional components will help you determine which components should be used to
                implement any given scenario or use case. In turns it will allow you to develop
                powerful and efficient Synapse configurations thus putting the ESB to maximum use.
            </p>
            <p>
                As of now Synapse mediation engine consists of following functional elements:
            </p>
            <p>
                <ul>
                    <li>Mediators and sequences</li>
                    <li>Endpoints</li>
                    <li>Proxy services</li>
                    <li>Scheduled tasks</li>
                    <li>Event sources</li>
                    <li>Sequence templates</li>
                    <li>Endpoint templates</li>
                    <li>Registry adapter</li>
                    <li>APIs</li>
                    <li>Priority executors</li>
                    <li>Message stores and processors</li>
                </ul>
            </p>
            <subsection name="Mediators and Sequences">
                <p>
                    The Synapse ESB defines a 'mediator' as a component which performs a predefined
                    action on a message during a message flow. It is the most fundamental message
                    processing unit in Synapse. A mediator can be thought of as a filter that resides
                    in a message flow, which processes all the messages passing through it.
                </p>
                <p>
                    A mediator gets full access to the messages at the point where it is defined.
                    Thus they can inspect, validate and modify messages. Further, mediators can take
                    external action such as looking up a database or invoking a remote service,
                    depending on some attributes or values in the current message. Synapse ships
                    with a variety of built-in mediators which are capable of handling an array of
                    heterogeneous tasks. There are built-in mediators that can log the requests,
                    perform content transformations, filter out traffic and a plethora of other
                    messaging and integration activities.
                </p>
                <p>
                    Synapse also provides an API using which custom mediators can be implemented
                    easily in Java. The 'Class' and 'POJO (command)' mediators allow one to plugin a
                    Java class into Synapse with minimal effort. In addition, the 'Script' mediator
                    allows one to provide an Apache BSF script (eg: JavaScript, Ruby, Groovy etc)
                    for mediation.
                </p>
                <p>
                    A mediation sequence, commonly called a 'sequence' is a list of mediators. A
                    sequence may be named for re-use, or defined in-line or anonymously within a
                    configuration. Sequences may be defined within the Synapse configuration or in
                    the Registry. From an ESB point of view, a sequence equates to a message flow.
                    It can be thought of as a pipe consisting of many filters, where individual
                    mediators play the role of the filters.
                </p>
                <p>
                    A Synapse configuration contains two special sequences named 'main' and 'fault'.
                    These too may be defined in the Synapse configuration, or externally in the
                    Registry. If either is not found, a suitable default configuration is generated at
                    runtime by the ESB. The default 'main' sequence will simply send a message without
                    any mediation, while the default 'fault' sequence would log the message and error
                    details and stop further processing. The 'fault' sequence executes whenever Synapse
                    itself encounters an error while processing a message, or when a fault handler has
                    not been defined to handle exceptions. A sequence can assign another named sequence
                    as its 'fault' handler sequence, and handover control to the fault handler if an
                    error is encountered during the execution of the initial sequence.
                </p>
            </subsection>
            <subsection name="Endpoints">
                <p>
                    An Endpoint definition within Synapse defines an external service endpoint and
                    any attributes or semantics that should be followed when communicating with that
                    endpoint. An endpoint definition can be named for re-use, or defined in-line or
                    anonymously within a configuration. Typically an endpoint would be based on a
                    service address or a WSDL. Additionally the Synapse ESB supports Failover and
                    Load-balance endpoints - which are defined over a group of endpoints. Endpoints
                    may be defined within the local Synapse configuration or within the Registry.
                </p>
                <p>
                    From a more practical stand point, an endpoint can be used to represent any
                    entity to which Synapse can make a connection. An endpoint may represent a
                    URL, a mail box, a JMS queue or a TCP socket. The 'send' mediator of Synapse
                    which is used to forward messages can take an endpoint as an argument. In that
                    case the 'send' mediator would forward the message to the specified endpoint.
                </p>
            </subsection>
            <subsection name="Proxy Services">
                <p>
                    A proxy service is a virtual service exposed on Synapse. For the external
                    clients, a proxy service looks like a full fledged web service which has a
                    set of endpoint references (EPRs), a WSDL and a set of developer specified
                    policies. But in reality, a proxy service sits in front of a real web service
                    implementation, acting as a proxy, mediating messages back and forth. The
                    actual business logic of the service resides in the real back-end web service.
                    Proxy service simply hides the real service from the consumer and provides
                    an interface through which the actual service can be reached but with some
                    added mediation/routing logic.
                </p>
                <p>
                    Proxy services have many use cases. A proxy can be used to expose an existing
                    service over a different protocol or a schema. The mediation logic in the proxy
                    can take care of performing the necessary content transformations and protocol
                    switching. A proxy service can act as a load balancer or a lightweight process
                    manager thereby hiding multiple back-end services from the client. Proxy services
                    also provide a convenient way of extending existing web services without changing
                    the back-end service implementations. For an example a proxy service can add logging
                    and validation capabilities to an existing service without the developer having
                    to implement such functionality at service level. Another very common usage of
                    proxy services is to secure an existing service or a legacy system.
                </p>
                <p>
                    A proxy service is a composite functional component. It is made of several
                    sequences and endpoints. Typically a proxy service consists of an 'in sequence',
                    an 'out sequence' and an endpoint. The 'in sequence' handles all the incoming
                    requests sent by the client. Mediated messages are then forwarded to the target
                    endpoint which generally points to the real back-end service. Responses coming
                    back from the back-end service are processed by the 'out sequence'. In addition
                    to these a 'fault sequence' can also be associated with a proxy service which
                    is invoked in case of an error.
                </p>
                <p>
                    In addition to the above basic configuration elements, a proxy service can
                    also define a WSDL file to be published, a set of policies and various other
                    parameters.
                </p>
            </subsection>
            <subsection name="Scheduled Tasks">
                <p>
                    A scheduled task is a job deployed in the Synapse runtime for periodic execution.
                    Users can program the jobs using the task API (Java) provided by Synapse. Once
                    deployed, tasks can be configured to run periodically. The execution schedule
                    can be configured by specifying the delay between successive executions or using
                    the Unix Cron syntax.
                </p>
            </subsection>
            <subsection name="Remote Registry and Local Registry (Local Entries)">
                <p>
                    Synapse configuration can refer to an external registry/repository for resources
                    such as WSDLs, schemas, scripts, XSLT and XQuery transformations etc. One or
                    more remote registries may be hidden or merged behind a local registry interface
                    defined in the Synapse configuration. Resources from an external registry are
                    looked up using 'keys' - which are known to the external registry. The Synapse
                    ESB ships with a simple URL based registry implementation that uses the file system
                    for storage of resources, and URLs or fragments as 'keys'.
                </p>
                <p>
                    A registry may define a duration for which a resource served may be cached by the
                    Synapse runtime. If such a duration is specified, the Synapse ESB is capable of
                    refreshing the resource after cache expiry to support dynamic re-loading of resources
                    at runtime. Optionally, a configuration could define certain 'keys' to map to locally
                    defined entities. These entities may refer to a source URL or file, or may be defined
                    as in-line XML or text within the configuration itself. If a registry contains a
                    resource whose 'key' matches the key of a locally defined entry, the local entry
                    shadows the resource available in the registry. Thus it is possible to override
                    registry resources locally from within the configuration. To integrate Synapse with
                    a custom/new registry, one needs to implement the org.apache.synapse.registry.Registry
                    interface to suit the actual registry being used.
                </p>
            </subsection>
        </section>
    </body>
</document>